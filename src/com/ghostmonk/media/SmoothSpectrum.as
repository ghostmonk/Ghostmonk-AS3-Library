package com.ghostmonk.media{		import flash.display.Sprite;	import flash.display.BitmapData;	import flash.utils.ByteArray;	import flash.events.Event;	import flash.display.Shape;	import flash.geom.Point;	import flash.filters.BlurFilter;	import flash.display.Bitmap;	import flash.media.SoundMixer;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.events.MouseEvent;	import flash.geom.Matrix;	import flash.errors.EOFError;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	/** 	 * @author ghostmonk	 * 	 */	public class SmoothSpectrum extends Sprite	{				// data members		private var nAmp:int;		private var myBytes:ByteArray;		private var myPoints:Array;		private var midPoints:Array;		private var colors:Array;		private var ratios:Array;		private var alphas:Array;		private var matrix:Matrix;		private var blendArray:Array;		private var blendStyle:String;				private var i:int;		private var offset:Number;			private var lng:int;		private var curveLng:int;		private var midPointX:Number;		private var midPointY:Number;		private var mouseDown:Boolean;				// graphic members		private var myCurve:Shape;		private var myScreen:BitmapData;		private var myPoint:Point;		private var myBlur:BlurFilter;		private var myColorTrans:ColorTransform;		private var displace:Matrix;				public function SmoothSpectrum ( pWidth:Number , pHeight:Number, pAmplitude:int )		{			y = -30;			// our bitmap screen, where the curves are drawn			myScreen = new BitmapData ( pWidth, pHeight, true, 0 );						// using multiple of 2 increases performance by 40%			myBlur = new BlurFilter ( 2, 2, 2 );						// colorTransformation			myColorTrans = new ColorTransform ();						myColorTrans.color = Math.random()*0xFFFFFF;						// add it to the displayList			addChild ( new Bitmap ( myScreen ) );						// byteArray to hold frequencies			myBytes = new ByteArray();						//rotate it				displace = new Matrix();						// points holder			myPoints = new Array();						// midpoints holder			midPoints = new Array();						// set the wavin' amplitude			nAmp = pAmplitude;						// the curve to draw the spectrum			myCurve = new Shape();						// the point			myPoint = new Point ( 0, 0 );						// setup color gradients			colors = [0x8060B2, 0x12FFCF];			alphas = [100, 100];			ratios = [0, 255];			matrix = new Matrix();			matrix.createGradientBox ( pWidth, 1, 0, 0, 0);						addEventListener (Event.ADDED_TO_STAGE, onAdded);		}				private function onAdded ( pEvt:Event ):void 		{			addEventListener (Event.ENTER_FRAME, updatePoints);				addEventListener ( Event.REMOVED, onRemoved );					}					public function onRemoved( pEvt:Event ):void 		{			myScreen.dispose();			removeEventListener(Event.ENTER_FRAME, updatePoints );		}				private function updatePoints (e:Event):void		{						// clear each frame			myCurve.graphics.clear();						myCurve.graphics.lineStyle (1);						// apply gradient to the line			myCurve.graphics.lineGradientStyle ( 'linear', colors, alphas, ratios, matrix, 'pad', 'linearRGB', 0.1);						// generate the ByteArray			SoundMixer.computeSpectrum ( myBytes, false );						i = 16;						while ( --i > -1 )			{															// change the position of the pointer				myBytes.position = i * 128;								// get frequency				offset = myBytes.readFloat()*nAmp;								// push each points 				myPoints[i] = new Point ( int(-20 + ( 40 * i )), int(200 + (-offset)) );							}						lng = myPoints.length;						// now generate a mid-point array			// to make those mid-points the curve anchor points			for (var j:int = 1; j< lng; j++ )			{								midPointX = ( myPoints[j].x + myPoints[int(j-1)].x )/2				midPointY = ( myPoints[j].y + myPoints[int(j-1)].y )/2								midPoints[int(j-1)] = new Point ( int(midPointX), int(midPointY) );			}						// make the curve start at the first mid-point location			myCurve.graphics.moveTo ( midPoints[0].x, midPoints[0].y );						curveLng = lng-1;						// then draw the curve			for (var k:int = 1; k< curveLng; k++ )				myCurve.graphics.curveTo ( myPoints[k].x, myPoints[k].y, midPoints[k].x, midPoints[k].y );			// scroll the bitmap			myScreen.scroll ( 1, 0 );			// draw curve vectors on the BitmapData			myScreen.draw ( myCurve, null, null, "add" );						myScreen.applyFilter ( myScreen, myScreen.rect, myPoint, myBlur );					}			}}